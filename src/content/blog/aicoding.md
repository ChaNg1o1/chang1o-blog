---
title: 'AI Coding'
description: '直到2025年末我才真正清醒过来...'
pubDate: '2026-01-03'
tags: ['AI', '技术思考', '开发效率']
---

直到2025年末我才真正清醒过来：还在拿着旧时代的锤子找钉子？

这几天看技术社区的讨论，很有意思，大家还在为了Vue3的某个新特性或者是Java Spring Boot的某个注解吵得不可开交...

是这些技术不行了吗？当然不是。但在2026年的今天，看着这些讨论，我只感觉到一种错位的荒谬感。

说难听点，如果你是做产品优先，或者你是走Indie Hacker路线的，这种做法简直就是拿着上个世纪的锤子，在AI时代硬找钉子。如果你是为了大厂找工作，那这篇文章你现在就可以关掉了，继续背你的八股文；但如果你想追AI4SE的热点，想搞"一人军团"，想在这个时代活得像个样子...

那咱们得坐下来，好好聊聊什么叫"清醒"。

## 常见的误区：你以为的AI Native只是加个对话框？

很多朋友的误区是：AI Native就是把传统的App做出来，然后接个API加个Chatbox。

非也...

真正的AI First，是从技术选型、架构思维到开发流的彻底重构。

**先复习一下基本概念：为什么我劝你放弃传统Vue3和Java？**

在产品优先的逻辑下，**Java太重了**。JVM的启动速度、内存占用，在Serverless和Edge Function大行其道的今天，显得格格不入。你说Kotlin？哪怕你有KMP，除非你能打通全链路，否则对于Indie来说，由于上下文切换带来的认知负担太重。

再看前端。为什么我说React RSC和Next.js够香了？因为**React2Shell**对于独立产品来说，能解决90%的问题。

更深一层的逻辑在于：**你的技术栈必须对AI"友好"。**

* **UI层：** 为什么推荐 **Tailwind CSS** 和 **ShadcnUI**？不是因为它们长得好看，而是因为它们是高度结构化、语义化的。AI读得懂，写得快。React Scan和Grab甚至自带Prompt功能，这才是顺势而为。
* **交互层：** 动效用Rive，UI设计用Figma Make DSL。这一切都是为了让AI能更好地理解你的意图。

**后端？业务逻辑就完事了！**

不管三七二十一，Backend直接选 **Convex**，状态Query用 **Tanstack**。数据库？**PostgreSQL** 加上 **pgVector** 做向量存储，ORM层用 **Drizzle**。

你可能会问："底层的原理不需要了解吗？"

这恰恰是最大的思维陷阱。大部分人根本不需要知道底层的为什么。**Supabase** 这种BaaS把最新技术包得已经很好了。Auth用 **Better Auth**，AI集成用 **Vercel SDK** 和 **Firecrawl**。

**珍惜AI Coding带来的机会，把你的时间花在只有人类能定义的"业务逻辑"上，而不是去造轮子。**

## 架构师思维：从"写代码"到"指挥Agent"

有了上面的基础，我们才能吵架...啊不，讨论点更有深度的东西。

你真的清楚 **Bun** 被收购背后的信号吗？这不仅仅是JS运行时的胜利，这是**全栈工程师定义**的重写。

在AI时代，如果你需要了解底层原理来实现一个需求，你会第一时间想到去翻几千页的文档，头铁硬啃？还是会第一时间想到Codex、Claude？

这其实就是在讲：**怎么做专业的AI Coding。**

现在的开发，不再是当"小兵"写循环语句，而是要有**架构师思维**。你需要关注的是：

* **GitOps、AIOps、DevSecOps：** 因为未来Dev实践中，Token的使用量会绝对爆发。
* **CI/CD与自愈：** 为什么 **Manus Container** 团队和 **Blacksmith** 能融那么多钱？因为弹性云容器和自动化部署是AI Coding落地的基础设施。

**指挥Agent的艺术**

你需要做的，是维护一套**结构化的PRD模板**，以及 **Fill-in hook脚本** 和 **Workflow**。

这决定了你写的代码是否是一次性软件。不要试图通过 Prompt Injection 去赋予AI"人格"，那是上游模型厂该干的事（通过约束解码实现）。你需要做的，是上下文工程。

以前我们觉得70%的软件工程师自动化率就非常高了，现在有了Amp、Augment和Conductor这些工具做示范，上下文工程做得好，这个数字已经刷到了80%（九坤那种量化交易的不算）。

现在的瓶颈并非只在 模型变大，而在 上下文利用。目前的模型还没有 压缩感知能力，所以你更需要通过外部的工具链来管理上下文。

## 硬核实践：激进派的工具链选择

本文前半部分比较客观；接下来的后半部分更加主观，是给那些真正想做"激进AI Coding"的人看的。

很多朋友上来就用Cursor，觉得这就很先进了。

但在最佳实践中，我甚至认为Cursor都不够激进。

* **IDE与Agent：** 很多人最近切换到了 **OpenCode**。为什么？因为它支持更高的自定义、循环代理和复合工程。试试 `while :; do cat prompt.md | amp; done`，或者是 **Gas town + Ralph Wignum**，这种能够完整做栈迁移的工具链才是未来。
* **版本控制的革命：** 我立即替换了Git，转而使用 **Jujutsu**。为什么？因为它的状态机设计和声明式风格对AI更友好。Git的线性历史在AI的高频迭代下显得太笨重。
* **RPC的选择：** 能 **tRPC** 或者 **oRPC** 就用，打通端到端类型安全。

**AI原生开发的终极目标是 远离键盘。**

听起来很离谱，简直不可用...人类只负责Review，一切AI优先。

但这正是我们追求的：基于合同的构建思路，始终保持 API First 和 DX First。后续再加上 bash 自动化迭代，大量单元集成测试。日志应该面向 大语言模型 设计，学习 **Posthog** 为后续监测打基础。

## 认知与心法：在这个草台班子世界里套利

上面说了这么多技术，其实...**AI时代品味和好奇心才是太重要了。**

2025年是真正可以用原生AI Native进行开发的一年。但大部分场景下，瓶颈不在AI，而在**人**身上。

**1. 认知的降维打击**

世界就是一个巨大的草台班子。你要清楚认识到这一点，并且学会"吹牛"——这不是贬义词，这是CEO才有的叙事能力。

如果你有高认知，你可以做的太多了：

* **Crypto/Web3：** 资产配置、预测市场、BTC bot。
* **灰产与套利：** 很多人低估了灰产。自动洗稿、追热点分发（小红书、公众号矩阵），这里面涉及到Signal的捕捉，GLM 4.7其实已经挺不错了。垂直领域的Agent应该基于Claude Code，hook和Skill记忆分层，别自己造轮子。
* **Indie App出海：** 数字游民地理套利，招募几个数字员工24小时干活。

**2. 只有"广度"才能带来Alpha**

不要沉迷于钻牛角尖。除非你是搞内核的，否则**广度知识优先**。对我而言，另类数据的分析远比深究一个算法更有用。

* **信息源：** 订阅 Building in public 的 List，定期看 Hacker News、Reddit、Substack，关注 Y Combinator、A16z、Vercel、CNCF 的动态。
* **Early Adopter：** 出了新东西就去用。用了，你就超过了99%的 Peer。
* **Building in public：** 跑通一人公司你能学到很多，这才是真正的全栈，而不是你会写前端又会写后端。

**3. 生物黑客是基础设施**

最后，回到人本身。

既然你要做 一人军团，你的精力就是最重要的资源。
**茶氨酸、南非醉茄、甘氨酸镁...** 这些生物黑客的方法是个好东西。持续学习是最稳定的Alpha，而强健的神经系统是你承载这些高密度信息的容器。

## 结语

从22年末开始使用ChatGPT，到大众认识DeepSeek，再到真正有了"Manus"，这短短几年，进化速度令人咋舌。

上一步你还在捣鼓 **n8n** 的自动化，下一步 **Claude Code Workflow Skill** 直接摧毁了你的大部分场景；上一步你还在想怎么用 Deep Research 跑通垂类文档，下一步 **AnyGen** 出来了，专利分析变得如此简单...

不要追求圣杯或者银弹。有好的 Wrapper 就用，选择地壳一般的壳。

**你要做的就是 Async leading。** 安排好 TodoList，把繁琐的工作丢给AI，然后去做你想做的事情。

只要你真的懂了它的边界和正确的使用方法（开发工作流 + 研究工作流），一人军团，不再是梦。

千万不要拿着锤子找钉子。**干中学，现在就开始。**
